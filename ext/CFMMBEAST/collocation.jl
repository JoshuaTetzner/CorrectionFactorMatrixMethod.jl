"""
    sources(X::BEAST.Space, quadorder)

Functions samples quadrature points of given `quadorder` on each mesh element.

# Arguments

  - `X::BEAST.Space`: Basis function (Contains the mesh).
  - `quadorder`: Order of quadrature.
"""
function CorrectionFactorMatrixMethod.sources(
    space::BEAST.Space, quadorder::Int; dim=universedimension(space.geo)
)
    elements, _, _ = assemblydata(space)
    qp = BEAST.quadpoints(x -> refspace(space)(x), elements, (quadorder,))
    points = zeros(Float64, length(qp) * length(qp[1, 1]), dim)

    for (idx, pts) in enumerate(pts for element in qp for pts in element)
        points[idx, 1:dim] = pts.point.cart[1:dim]
    end

    return points, qp
end

"""
    potentials(qp::Matrix, X::BEAST.LagrangeBasis)

Function computes a sparse matrix that convertes the action of test and trial functions
onto weighted sums over the quadrature points.

# Arguments

  - `qp::Matrix`: Matrix containing the quadrature points and weights,
    generated by `BEAST.quadpoints()`.
  - `X::BEAST.LagrangeBasis`: Basis function.
"""
function CorrectionFactorMatrixMethod.potentials(qp::Matrix, X::BEAST.LagrangeBasis)
    rfspace = refspace(X)
    _, tad, _ = assemblydata(X)
    len = length(qp) * length(qp[1, 1]) * size(tad.data)[1] * size(tad.data)[2]

    rc = ones(Int, len, 2)
    vals = zeros(Float64, len)
    sind = 1

    for (ncell, cell) in enumerate(qp[1, :])
        ind = (ncell - 1) * length(cell)
        for (npoint, point) in enumerate(cell)
            val = rfspace(point.point)
            for localbasis in eachindex(val)
                for data in tad.data[:, localbasis, ncell]
                    if data[1] != 0 && ind + npoint != 0
                        rc[sind, 1] = ind + npoint
                        rc[sind, 2] = data[1]
                        vals[sind] = val[localbasis].value * point.weight * data[2]
                        sind += 1
                    end
                end
            end
        end
    end

    return rc, vals
end

"""
    potentialmatrix(qp::Matrix, X::BEAST.RTBasis)

Function computes a sparse matrix that convertes the action of test and trial functions
onto weighted sums over the quadrature points.

# Arguments

  - `qp::Matrix`: Matrix containing the quadrature points and weights, generated by `BEAST.quadpoints()`.
  - `X::BEAST.RTBasis`: Basis function.
"""
function CorrectionFactorMatrixMethod.potentials(qp::Matrix, X::BEAST.RTBasis)
    rfspace = refspace(X)
    _, tad, _ = assemblydata(X)
    len = length(qp) * length(qp[1, 1]) * size(tad.data)[1] * size(tad.data)[2]
    rc = ones(Int, len, 2)
    vals = zeros(Float64, len, 3)
    sind = 1
    for (ncell, cell) in enumerate(qp[1, :])
        ind = (ncell - 1) * length(cell)
        for (npoint, point) in enumerate(cell)
            val = rfspace(point.point)
            for localbasis in eachindex(val)
                for data in tad.data[:, localbasis, ncell]
                    if data[1] != 0 && ind + npoint != 0
                        rc[sind, 1] = ind + npoint
                        rc[sind, 2] = data[1]
                        vals[sind, 1] = val[localbasis].value[1] * point.weight * data[2]
                        vals[sind, 2] = val[localbasis].value[2] * point.weight * data[2]
                        vals[sind, 3] = val[localbasis].value[3] * point.weight * data[2]
                        sind += 1
                    end
                end
            end
        end
    end

    return rc, vals
end

"""
    function getnormals(qp::Matrix)

Function computes the normal vector for each quadrature point.

# Arguments

  - `qp::Matrix`: Matrix containing the quadrature points and weights,
    generated by `BEAST.quadpoints()`.
"""
function getnormals(qp::Matrix)
    normals = zeros(Float64, length(qp) * length(qp[1, 1]), 3)
    for (i, points) in enumerate(qp[1, :])
        for (j, point) in enumerate(qp[1, i])
            normals[(i - 1) * length(points) + j, :] = BEAST.normal(point.point)
        end
    end

    return normals
end
